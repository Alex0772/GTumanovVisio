<html><head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
</head>
<body>
<p>	Привет, меня зовут Джон Голдсмит, и это вторая и заключительная часть краткого курса Visio для разработчиков.</p>
<p>0:09</p>
<p>	Если вы не смотрели первый модуль, я бы очень рекомендовал вам сделать это, поскольку он охватывает большую часть структуры и функциональности, которую использует код в этом модуле.</p>
<p>0:20</p>
<p>	Одна из вещей, которая делает Visio таким мощным, - это очень существенный API, который стоит за ним. Под существенным я подразумеваю как вширь, так и вглубь. Вы можете кодировать для visio на нескольких различных языках, начиная от VBA и заканчивая C# и C++.</p>
<p>0:34</p>
<p>	Итак, я собираюсь начать этот модуль с рассмотрения того, что это за варианты и как вы решаете, какие из них использовать. Как только мы рассмотрим варианты, я собираюсь совершить экскурсию по объектной модели, выделить важные части Vision и посмотреть, как они связаны друг с другом.</p>
<p>0:51</p>
<p>	Затем я снова перейду к обработке событий в Visio, рассматривая множество доступных там опций, и, наконец, закончу модуль, рассмотрев, как вы собираетесь развертывать код, трафареты и шаблон вашего решения на компьютере конечного пользователя.</p>
<p>1:04</p>
<p>	Как я упоминал в первой части, я хотел, чтобы этот курс дал вам действительно хороший обзор основ программирования в Visio. И существуют несколько областей, которые, по моему мнению, не вписываются в эту категорию, но для полноты картины я упомяну и те, которые не буду освещать.</p>
<p>1:21</p>
<p>	Во-первых, это Visio Services. Это функция Sharepoint присутствует как в настольной, так и в онлайн версии, и она работает как служба, аналогичная службам Excel.</p>
<p>1:28</p>
<p>	Она доступна только в корпоративной версии Sharepoint Server, а также с бесплатной или более старшими подписками его онлайн-аналога.	</p>
<p>1:34</p>
<p>	Visio Services заслуживают отдельного курса и выходят за рамки данного курса, который посвящен пониманию основ Visio.</p>
<p>1:45</p>
<p>	Как и остальная часть Office, Visio использует Open Packaging формат файла, который можно распаковать, чтобы предоставить документ в виде XML.</p>
<p>1:51</p>
<p>	Несмотря на то, что принцип упаковки уже знаком тем, кто работал с файлами Word, Excel или Powerpoint, используемые в них XML-схемы могут оказаться незнакомыми.</p>
<p>2:02</p>
<p>	В SDK есть несколько рабочих примеров создания файлов Visio вне приложения, а также доступны схемы, которые помогут в этой работе.</p>
<p>2:09</p>
<p>	В дополнение к основному приложению Microsoft также предоставляет Viewer - средство просмотра документов Visio.</p>
<p>2:15</p>
<p>	Опять же, SDK предоставляет документацию о том, как можно расширить и включить такую функциональность в свои собственные решения, если требуется открыть документ только для чтения.</p>
<p>2:22</p>
<p>	Итак, давайте углубимся и посмотрим, какие существуют варианты расширения Visio.	</p>
<p>2:34</p>
<p>	Варианты расширения</p>
<p>	Когда заходит речь о расширении с помощью кода решения Visio в настольном клиенте, у вас есть несколько вариантов.</p>
<p>2:40</p>
<p>	Их можно рассматривать как три основные технологии, каждая из которых имеет ряд вариаций. Есть VBA, Add-ons и Add-ins. Помимо этих трех стандартных вариантов, я также кратко упомяну два других - Visio Drawing Control and Powershell.</p>
<p>3:00</p>
<p>	Прежде всего давайте начнем с VBA. Visio использовал VBA еще до того, как его купила Microsoft. Язык практически такой же, что и в Excel, Word и Powerpoint.</p>
<p>3:12</p>
<p>	Главное отличие заключается в объектной модели, на которую мы сейчас посмотрим.</p>
<p>3:18</p>
<p>	Другое важное отличие заключается в том, где вы будете хранить свой код. В отличие от Excel и Word, которые могут централизованно хранить код в специальной книге или шаблоне, Visio не имеет такого единого файла. Одним из вариантов может быть размещение вашего кода в шаблоне документа, который предоставит вам доступ к коду во всех документах, созданным на основе этого шаблона.</p>
<p>3:36</p>
<p>	Это, конечно, приводит к многократному повторению одного и того же кода, что явно не является хорошей ситуацией.</p>
<p>3:42</p>
<p>	Более удобным будет размещение вашего кода в трафарете. Открытые трафареты записываются в данных о рабочей области шаблона. Поэтому одни и те же трафареты будут открываться в каждом новом чертеже, основанном на этом шаблоне, а вместе с ними и ваш код.</p>
<p>3:56</p>
<p>	VBA по-прежнему отлично подходит для создания прототипов и решений, ориентированных на довольно небольшое количество пользователей. Но если вы хотите распространить свое решение более широко или воспользоваться более широкими возможностями, найденными в других языках и фреймворках, то более полезными будут Add-on и Add-in.</p>
<p>4:15</p>
<p>	Add-on позволяют создавать как функциональные возможности уровня приложения, так и дополнительные функции. Так мастер организационных диаграмм, brainstorm-диаграмм, кросс-функциональная блок-схема подключаются именно с помощью этого метода.</p>
<p>4:32</p>
<p>	Add-on могут быть реализованы одним из двух способов - в виде vsl-файла или в виде exe-файла. Vsl или Visio solution library, которая на самом деле является библиотекой dll с другим расширением файла, может содержать несколько дополнений и поскольку это библиотека dll, она выполняется в том же процессе, что и Visio. Vsl экспортирует единую точку входа с именем VisioLibMain, и Visio использует ее для отправки вашему vsl ряда сообщений, таких как запрос о том, какие дополнения содержит ваш vsl, чтобы определить, включено ли конкретное дополнение или нет, или, что наиболее важно, для запуска Add-on.</p>
<p>5:06</p>
<p>	Хотя VSL, как правило, написаны на C+, они могут быть реализованы на любом языке, который может создавать DLL и экспортировать точку входа.</p>
<p>5:13</p>
<p>	Вы также можете реализовать надстройку в виде exe-файла. Она может быть написана на любом языке, который поддерживает автоматизацию и, в отличие от VSL, выполняется в отдельном процессе.</p>
<p>5:26</p>
<p>	Основное преимущество работы в отдельном процессе заключается в том, что код может продолжать выполняться как до, так и после завершения работы Visio.</p>
<p>5:34</p>
<p>	Недостатком, конечно, является то, что вы платите за снижение производительности из-за межпроцессных вызовов.</p>
<p>5:40</p>
<p>	Близко к Add-on находятся Add-in. Кстати, пока речь идет о классических Add-in на основе COM, и их не следует путать с более поздними надстройками Office Add-in, которые основаны на html и javascript.	</p>
<p>5:53</p>
<p>	Если рассматривать в совокупности с остальными office Add-in, то имеется три основных вида, каждый из которых выполняется в том же процессе, что и Visio.</p>
<p>6:01</p>
<p>	Это COM Add-in, Shared Add-in и VSTO или Visual Studio Tools for Office Add-in. COM и Shared Add-in реализуют интерфейс IDTExtensibility, с такими методами, как OnConnection и OnDisconnection, в качестве основы связи между Visio и целевым Add-in.</p>
<p>6:21</p>
<p>	COM Add-in создаются с использованием неуправляемого (unmanaged) кода, такого как VB6 или C++, в то время как Shared Add-in позволяют писать управляемый (managed) код.</p>
<p>6:32</p>
<p>	Shared Add-in страдают от двух основных проблем. Во-первых, несколько надстроек помещаются в один и тот же домен приложения по умолчанию, это означает, что если одна надстройка генерирует необработанное исключение, это может привести к отключению всех других надстроек в том же домене приложения. Во-вторых, это невозможность подписать ваш код, а значит перспектива того, что ваша надстройка не загрузится, когда установлен высокий уровень безопасности пользователя.</p>
<p>6:56</p>
<p>	Это из-за того, что mscoree.dll, в которой находится CLR, а значит и COM interop, должна быть загружена и зарегистрирована перед вашей управляемой dll.</p>
<p>7:08</p>
<p>	Очевидно, что вы не можете подписать mscoree.dll, но это то, что Visio видит в качестве основной сборки. Это действительно была проблема всего офиса, и обе эти проблемы были решены с введением COM-оболочки, которая упаковывала ваш код, позволяя вам правильно его подписывать, а также загружать его в отдельный домен приложения.</p>
<p>7:21</p>
<p>	Хотя оболочка справилась с проблемой, ее создание было несколько сложным, а также официально не поддерживалось Microsoft. Поэтому в итоге были введены VSTO Add-in, которые содержали аналогичную встроенную оболочку в виде VSTO loader, решающую вопросы изоляции, безопасности и простоты внедрения.</p>
<p>7:41</p>
<p>	Другие возможности</p>
<p>	Прежде чем я расскажу, как выбрать один из трех основных вариантов расширения, я хотел бы кратко упомянуть два других способа взаимодействия с Visio.</p>
<p>7:55</p>
<p>	Первый - это Visio Drawing Control. Это ActiveX, который оборачивает библиотеку типов Visio и позволяет размещать область рисования Visio в вашем собственном приложении, таком как Windows Form, WPF-приложение или даже другое приложение Office.</p>
<p>8:07</p>
<p>	Drawing Control - это, по сути, полный Visio с парой ограничений. Поскольку это интерфейс с одним документом, вы можете загружать только один документ за раз, кроме того он не будет выполнять VBA код, который может присутствовать в документе.</p>
<p>8:25</p>
<p>	В SDK есть простое Windows Form  приложение и я сейчас его запущу. Вы можете видеть, что у нас есть три кнопки, которые соответствуют трем мастер-шейпам в скрытом трафарете.</p>
<p>8:37</p>
<p>	Drawing Control имеет свойство Source, которое позволяет открывать в любой момент только один документ-рисунок, но это не мешает по мере необходимости свободно открывать другие трафареты.</p>
<p>8:44</p>
<p>	Если я буду нажимать на кнопки, вы увидите, что можно взаимодействовать с этими шейпами так же, как в Visio, и можете управлять, какую часть изображения и какие элементы управления шейпами сделать видимыми.</p>
<p>9:03</p>
<p>	Это отличное приложение, которое я действительно рекомендую вам попробовать, поскольку оно охватывает чтение данных, удаление шейпов и просмотр участков рисунка.</p>
<p>9:09</p>
<p>	Таким образом, это превращает Visio в элемент управления, который может работать в вашем собственном приложении.</p>
<p>9:21</p>
<p>	Вторая технология, о которой я хотел бы поговорить, - это Powershell. Поскольку Powershell способен создавать COM-объекты и взаимодействовать с ними, вы можете свободно взаимодействовать с Visio, как с любым другим COM-приложением, таким как Excel или IE.</p>
<p>9:33</p>
<p>	Итак, в качестве примера я собрал простой демонстрационный скрипт, который загружает клиент Sharepoint Online, а затем выводит структуру обнаруженных сайтов и веб-объектов.</p>
<p>9:46</p>
<p>	Все общение с Sharepoint Online ведется благодаря офисным патентам и командлетам Powershell и демонстрируют одно из основных преимуществ использования Powershell с Visio, а именно обширную библиотеку командлетов Powershell, которая позволяет автоматизировать локальную инфраструктуру вплоть до облачных платформ, таких как Office 365 и Azure.</p>
<p>10:05</p>
<p>	Итак, давайте посмотрим на это в действии.</p>
<p>10:13</p>
<p>	Это один скрипт. В нем я собрал небольшой класс, используя функциональность класса, доступную в Powershell 5. На этом изображении вы можете видеть, что класс имеет ряд методов, которые позволяют вам размещать экземпляры мастер-шейпов на странице либо как отдельную шейп, либо как иерархический дочерний элемент другого шейпа.</p>
<p>	10:30</p>
<p>	</p>
<p>Класс сохраняет некоторые данные о состоянии как с для текущего рассматриваемого шейпа, так и для коллекции мастеров, которые могут охватывать несколько трафаретов.</p>
<p>10:44</p>
<p>	Раздел методов касается итерации по семействам сайтов и подчиненным сайтам.</p>
<p>10:49</p>
<p>	Все это запускается с помощью командлета New-OnlineTenantDiagram. Вы можете видеть, что я начинаю с создания нового экземпляра этого класса и передачи имени шаблона, уже зарегистрированного в Visio. Затем следует размещение шейпа Tenant верхнего уровня, заполнение данных шейпа, а затем выполнение цикла по всем свойствам коллекции сайтов в коллекции сайтов.</p>
<p>11:16</p>
<p>	Затем я рекурсивно перебираю все веб-объекты, добавляя шейп и заполняя данные шейпа для каждого из них.</p>
<p>11:22</p>
<p>	Теперь на самом деле запустим это и посмотрим, что произойдет.</p>
<p>11:29</p>
<p>	Я передаю URL администратора для тенанта, который мне нужен, а также именованные учетные данные, которые я добавил в качестве общих учетных данных в Windows.</p>
<p>11:50</p>
<p>	Если я немного увеличу масштаб и выберу окно данных шейпа, вы можете увидеть, что я присвоил этому веб-объекту несколько свойств. Но вам решать, какие свойства вы хотите отразить в шейпе и, в в итоге показать их.</p>
<p>12:05</p>
<p>	Таким образом, с помощью нескольких строк кода PowerShell я смог собрать чрезвычайно гибкий инструмент, позволяющий вам выбирать, какие свойства и объекты будут отображаться визуально для мониторинга вашей собственной платформы.</p>
<p>12:19</p>
<p>	Если вы используете Powershell на регулярной основе, имеется отличный проект с открытым исходным кодом под названием Visio Powershell, который действительно стоит изучить. Проект был создан сотрудником Microsoft по имени Савин Редди, который проделал потрясающую работу по соданию оболочки для некоторых наиболее трудоемких и сложных частей взаимодействия с Visio через Powershell.</p>
<p>12:38</p>
<p>	Итак, возвращаясь к основным вариантам - как вы выбираете, какой из них будет использоваться для разработки вашего решения.</p>
<p>12:45</p>
<p>	Помимо определенных языковых навыков, которыми вы или ваша команда можете располагать, каждый вариант предлагает ряд преимуществ.</p>
<p>12:50</p>
<p>	VBA прост в написании и легко доступен.</p>
<p>12:56</p>
<p>	Я часто делаю прототип чего-либо в VBA прежде чем конвертировать в C#, мне так удобнее всего.</p>
<p>13:03</p>
<p>	Если у вас очень небольшое количество конечных пользователей или эти пользователи умеют добавлять и модифицировать код, тогда VBA может быть гибким и удобным выбором.</p>
<p>13:10</p>
<p>	Однако, при увеличении количества пользователей VBA становится все сложнее распространять и, что важно, поддерживать, и именно здесь вы, возможно, захотите взглянуть на некоторые свойства Add-in.</p>
<p>13:22</p>
<p>	В большинстве случаев я бы сказал, что VSTO Add-in — это то, что нужно.</p>
<p>13:28</p>
<p>	Тем не менее, Shared COM Add-in имеют преимущество работы с несколькими офисными приложениями, где VSTO обычно зависит от приложения. Поэтому, если вам нужно обратиться к более чем одному приложению, вам следует рассмотреть Shared COM Add-in.</p>
<p>13:47</p>
<p>	Взглянем на Add-on. Различие между ними и Add-in раньше было более значительным. Только Add-on можно было вызывать непосредственно из ShapeSheet или с помощью постоянных событий.</p>
<p>13:54</p>
<p>	Например, вы можете включить функцию вызова Add-on из ShapeSheet формулы в ваших шейпах, но исторически этому не было эквивалента в Add-in.</p>
<p>14:08</p>
<p>	Это изменилось в 2003 году с появлением новой вспомогательной надстройки, называемой Queue Marker Event, которая позволяет обращаться к Add-in, помещая в очередь объекта Application событие Marker Event, а затем прослушивая это событие в rjlt вашего Add-in.</p>
<p>14:19</p>
<p>	Я собираюсь посмотреть на события в Visio позже в этом модуле, но для нашего сравнения вывод здесь таков, что выбор в наши дни, вероятно, больше зависит от вашего предпочтительного языка, а не от каких-либо очень существенных различий в функциональности.</p>
<p>14:32</p>
<p>	Конечно, существует разница между VSL Add-on, которые запускаются in-process, и Add-on на основе EXE, которые запускаются out-of-process. Если вам нужно, чтобы код запускался либо до запуска Visio, либо после его остановки, возможно, стоит подумать о EXE Add-on.</p>
<p>14:44</p>
<p>	С одной стороны, это может показаться привлекательным вариантом: вы создаете простую Windows Form или WPF приложение и просто ждете вызова со строкой аргумента, которая сообщает вам идентификаторы документа, страницы и формы, которые запустили событие. Однако путь EXE несет в себе некоторое количество ограничений.</p>
<p>15:02</p>
<p>	Например, ваш EXE получает только строку аргументов и не имеет прямых сведений о приложении, которое ее отправило. Это уже ваша задача - найти работающее приложение и убедиться, что это именно тот экземпляр, о котором вы думаете.</p>
<p>15:15</p>
<p>	Если пользователь вызывает Add-on во второй раз, создается новый экземпляр вашего EXE, поэтому может понадобиться реализовать стратегию обработки этих нескольких экземпляров в своей программе.</p>
<p>15:26</p>
<p>	Если вкратце, то EXE Add-on, как правило, используются в визардо-подобных сценариях, часто поддерживающих первоначальную настройку для определенного шаблона или средства выбора списка режимов, остающихся открытыми на протяжении всего жизненного цикла экземпляра приложения Visio и после него.</p>
<p>15:39</p>
<p>	Drawing Control явно подходит для тех сценариев, когда вам нужно встроить поверхность рисования Visio в ваше собственное приложение.</p>
<p>15:52</p>
<p>	Это позволяет вам предоставить пользователю все управление шейпами и процессом работы, но ограничить полный пользовательский интерфейс, который может выходить за рамки того, что требуется для приложения, ориентированного на одну задачу.</p>
<p>16:06</p>
<p>	Заключительная часть — Powershell. Это, очевидно, имеет смысл, если вы уже используете его для доступа к целевой системе. Он позволяет добавлять визуальные отчеты в Powershell, а также считывать данные из существующих диаграмм.</p>
<p>16:18</p>
<p>	Итак, теперь вы узнали о широком спектре возможностей, а я собираюсь перейти к рассмотрению объектной модели, так как она реально является ядром приложения.</p>
<p>16:28</p>
<p>	Объектная модель</p>
<p>	Visio предоставляет объектную модель, аналогичную другим офисным приложениям.	</p>
<p>16:34</p>
<p>	Как вы понимаете, все начинается с объекта Application. Он содержит коллекцию, содержащую ноль или более объектов Document. Документ имеет набор из одного или нескольких объектов Page, а страница содержит коллекцию объектов Shape.</p>
<p>16:52</p>
<p>	Каждый шейп имеет собственную коллекцию шейпов, представляющую вложенные шейпы в группе. Если не считать вложенных шейпов, здесь останавливается цепочка коллекций объекта. Однако концептуально вы все еще можете думать о шейпе как о коллекции секций в шейп-листе.</p>
<p>17:03</p>
<p>	Каждая секция содержит несколкьо строк, а каждая строка содержит несколько ячеек.</p>
<p>17:11</p>
<p>	Хотя существуют объекты Section, Row и Cell, для доступа к ячейкам обычно используются свойства шейпа.	</p>
<p>17:18</p>
<p>	Имеется два способа сделать это - по имени и по позиции. Например, чтобы получить доступ к формуле ячейки заливки по имени, вы должны использовать представление Shape.Cells и заполнить имя ячейки FillForegnd. А для доступа к той же ячейке по позиции вы должны использовать синтаксис секция-строка-ячейка, то есть свойство CellsSRC, передавая правильные значения позиций.</p>
<p>17:43</p>
<p>	Если вы хотите узнать имя или значения позиции для конкретной ячейки, просто откройте SDK и найдите соответствующую ссылку на ячейку, где вы найдете все необходимые сведения.</p>
<p>17:49</p>
<p>	И пусть ссылки потом перейдут к еще 80 или более объектам, в первую очередь нужно понять Application (приложение), Document (документ), Page (страницу), Shape (шейп) и Cell (ячейку).</p>
<p>18:07</p>
<p>	Кроме того, я назову еще несколько важных объектов, чтобы вы знали, где они находятся в иерархии. Все, что связано с выбором и просмотром, обрабатывается объектом Window (окно), который содержит свойство, возвращающее объект Selection (выбор).</p>
<p>18:20</p>
<p>	Вы можете использовать ActiveWindow.Selection, чтобы получить выбранные в данный момент шейпы, а затем добавлять и удалять элементы из этого выбора, используя связанные методы для объекта.</p>
<p>18:31</p>
<p>	Расположение объекта DataRecordset, о котором я говорил в предыдущем модуле, и объекта Validation подчеркивают ориентированный на документы характер этих двух функций.</p>
<p>18:37</p>
<p>	И, наконец, вы можете видеть, что коллекция Layers находится на уровне страницы.</p>
<p>18:45</p>
<p>	Итак, это базовая объектная модель. Давайте взглянем на короткую демонстрацию, чтобы показать, как вы удаляете шейпы и, что наиболее важно, как мы пишем в ячейки этих шейпов для настройки их внешнего вида.</p>
<p>19:02</p>
<p>	Вот макет кофейни. На этой диаграмме имеется несколько щейпов, в том числе два нестандартных шейпа, которые я собрал вместе и поместил в трафарет под названием "CoffeeStore". Шаблон также содержит вспомогательный код, который позволяет пользователю щелкнуть правой кнопкой мыши фигуру стола и добавить стул.</p>
<p>19:15</p>
<p>	Как видите, по мере добавления стульев новые и существующие стулья расставляются вокруг стола. Для этого я добавил действие или пункт контекстного меню в шейп стола.</p>
<p>19:35</p>
<p>	При этом используется вызов функции шейп-листа, которая позволяет вызывать код VBA в связанном документе.</p>
<p>19:40</p>
<p>	Он включает в себя метод и документ, определяющий, где можно найти код.</p>
<p>19:45</p>
<p>	В данном случае это метод AddChair. Вызов этой функции шейп-листа предполагает public метод, принимающий аргумент Shape, который Visio передает при вызове.</p>
<p>19:56</p>
<p>	Это дает ссылку на конкретный экземпляр  шейпа стола, откуда мы можем выполнить быстрый пространственный поиск для создания объекта Selection, который включает в себя все шейпы стульев, которые касаются или перекрываются с шейпом стола.</p>
<p>20:09</p>
<p>	После того, как вы выбрали существующие стулья, вы можете использовать метод Drop объекта Page, чтобы добавить новый экземпляр мастер-шейпа стула и включить его в Selection.</p>
<p>20:21</p>
<p>	Теперь, когда все стулья на месте, вы можете, наконец, расставить их, используя полярные координаты, вокруг целевого стола.</p>
<p>20:29</p>
<p>	Хотя я не хочу тратить слишком много времени на отдельные строки кода, пока вы просматриваете два основных метода, обратите внимание на места, где мы читаем и пишем в свойство Formula именованных ячеек.</p>
<p>20:41</p>
<p>	Это подчеркивает тот факт, что Cells лежат в основе работы Visio.</p>
<p>20:47</p>
<p>	Например, на первый взгляд вы можете ожидать, что объект Shape будет иметь свойства ширины и высоты, к которым вы можете получить прямой доступ, но это не так.</p>
<p>20:55</p>
<p>	Хотя объект Shape имеет ряд прямых свойств, в целом все, что связано с внешним видом шейпа, можно найти в шейп-листе.</p>
<p>21:01</p>
<p>	И поэтому стоит ознакомиться с тем, что там есть. Итак, теперь у нас есть понимание объектной модели и того, как с ней взаимодействовать. Я собираюсь перейти к ключевой области Visio, а именно к обработке событий.</p>
<p>21:18</p>
<p>	Обработа событий в Visio</p>
<p>	Visio предлагает широкий набор событий по всей объектной модели, позволяя вашему коду реагировать на различные изменения в приложении, сделанные пользователем или другим кодом.</p>
<p>21:29</p>
<p>	Существует ряд аспектов обработки событий в Visio. Я попытаюсь пройтись по ним в порядке сложности или, точнее говоря, от простого к сложному.</p>
<p>21:42</p>
<p>	Диапазон событий, предоставляемых Visio, начинается с событий, связанных с объектами высокого уровня, такими как AppActivated и DocumentOpened.</p>
<p>21:48</p>
<p>	Через события объекта среднего уровня, такие как PageAdded и ShapeAdded, и вплоть до событий уровня ячейки, таких как FormulaChanged и CellChanged. Хотя существует несколько способов прослушивания событий, в основном происходит следующее.</p>
<p>22:00</p>
<p>	У вас есть некоторый код, который может быть в документе VBA или, возможно, в  VSTO Add-in, и вы хотите отреагировать на какое-то событие, которое происходит в Visio.</p>
<p>22:13</p>
<p>	Со стороны Visio используются два объекта: Subject obj (субъект) - это то, с чем или в чем произошло событие; и Source obj (источник), это объект, сообщающий о событии.</p>
<p>22:24</p>
<p>	Прослушивая определенное событие в Source (исходном объекте), ваш клиентский код может затем обработать это событие и выполнить любые действия, которые вы решите выполнить.</p>
<p>22:30</p>
<p>	То, как это происходит, зависит от метода, который вы используете для подключения источника, и я добавлю его к этой диаграмме по мере изучения вариантов.</p>
<p>22:42</p>
<p>	Event Scope (Область видимости события)</p>
<p>	Исходный объект может быть одним из множества объектов, и точка, в которой вы организуете прослушивание, определяет область видимости событий, на которые вы можете реагировать.</p>
<p>22:49</p>
<p>	Это также может повлиять на производительность. Например, вот модель приложения с двумя документами и несколькими страницами.</p>
<p>22:59</p>
<p>	Если вы начнете прослушивать событие FormulaChanged, используя Application в качестве источника, тогда вашему коду придется обрабатывать все изменения формул во всех ячейках, во всех шейпах, на всех страницах и во всех документах, открытых в приложении.</p>
<p>23:15</p>
<p>	Это очень много событий. Лучшей стратегией будет сузить область действия, сосредоточив внимание на целевом документе или странице, чтобы ограничить количество событий, с которыми вам приходится иметь дело, и тем самым повысить производительность.</p>
<p>23:22</p>
<p>	Выбор области действия часто будет зависеть от типа проекта, который вы создаете. У Криса Хопкинса (члена команды Microsoft Informer Visio) есть запись в блоге, в которой он проводит четкое различие между типичными проектами надстроек как между инструментами и решениями.</p>
<p>23:40</p>
<p>	Он описывает инструмент как независимый от шаблонов или определенного набора шейпов, а решение, напротив, как зависящее от одного или нескольких шаблонов и связанных наборов шейпов.</p>
<p>23:48</p>
<p>	Тогда с точки зрения области действия для решения вы можете начать с прослушивания на уровне приложения событий DocumentOpened и DocumentCreated, чтобы определить, основан ли конкретный документ на одном из ваших шаблонов решения, а затем, если да, сужать дальнейшее прослушивание этого конкретного документа.</p>
<p>24:08</p>
<p>	Для инструментов ваша стратегия, скорее всего, будет на уровне приложения. Но даже в этом случае вы можете начать слушать, например, событие FormulaChanged только в том случае, если активное окно относится к нужному типу.</p>
<p>24:22</p>
<p>	Очевидно, что варианты инструментов довольно широки, но принцип сужать область прослушивания событий настолько, насколько это возможно, остается в силе.</p>
<p>24:27</p>
<p>	Итак, теперь вы знаете, где слушать события.</p>
<p>24:32</p>
<p>	Теперь рассмотрим варианты обработки событий.</p>
<p>	Компоненты событий</p>
<p>24:37</p>
<p>	Прежде чем я начну, давайте просто кратко рассмотрим все рабочие части. В шейп-листе имееся несколько Event-ячеек, которые позволяют вам реагировать на определенные события непосредственно в шейп-листе шейпа.</p>
<p>24:50</p>
<p>	В VBA есть модуль класса ThisDocument, который поставляется со всеми событиями документа. В языках на основе VB есть модификатор WithEvents, который позволяет объявить объектную переменную, включая ее интерфейс событий, а затем предоставить обработчики для каждого из событий, предоставляемых этим объектом.</p>
<p>25:03</p>
<p>	В .net вы можете подключаться к событиям, используя методы делегирования событий. Это методы, предоставляемые сборкой VisioPrimaryInterop, позволяют ссылаться на созданный вами метод обработчика.</p>
<p>25:20</p>
<p>	И, наконец, Visio также предоставляет вам собственные объекты событий. Каждый исходный объект имеет свойство EventList, представляющее собой коллекцию, в которую можно добавлять объекты событий.</p>
<p>25:26</p>
<p>	Объект Event выполняет одно из двух действий, и это определяется методом, который вы используете в EventList для его создания.</p>
<p>25:38</p>
<p>	Метод EventList.Add позволяет вам запускать Add-on, а метод AddAdvise позволяет вам предоставить свой собственный объект, который будет уведомлен о том, что произошло событие.</p>
<p>25:46</p>
<p>	Итак, это основные методы обработки событий, и через секунду я рассмотрю каждый из них более подробно.</p>
<p>25:52</p>
<p>	Но сначала я хотел бы выделить несколько важных областей функциональности событий, которые поддерживают эти основные методы.</p>
<p>25:58</p>
<p>	Как я уже упоминал, важным фактором является сужение области прослушивания. Visio предоставляет для этого метод фильтрации событий, который можно применять к объектам событий, созданным с помощью метода AddAdvise.</p>
<p>26:11</p>
<p>	Этот метод позволяет вам фильтровать события, которые будут получены вашим кодом, на основе типа объекта, такого как группа, мастер или документ; в диапазонах ячеек с использованием индексов столбцов, строк секции для установки верхнего и нижнего пределов;</p>
<p>26:29</p>
<p>по идентификаторам команд, например, для захвата операций вырезания и вставки или при выборе инструментов коннектора или текстового блока; и при выборе событий мыши, например, чтобы получать только события Drop, но не начала или заверешения ввода текста.</p>
<p>26:41</p>
<p>	Сохраняемые (Persistent) события — это механизм, позволяющий сохранять событие, запускающее Add-on, в файле.</p>
<p>26:52</p>
<p>	Так, например, чтобы он автоматически подключался и был готов к запуску в следующий раз, когда файл открывается, не требуя дополнительного кода.</p>
<p>26:59</p>
<p>	Есть только несколько событий, которые на самом деле сохраняемы, например, DocumentOpened и MasterAdded.</p>
<p>27:05</p>
<p>	Но главное в том, что они освобождают вас от постоянного прослушивания событий во всех документах, позволяя запускать целевой Add-on только при необходимости.</p>
<p>27:10</p>
<p>	MarkerEvents — это события объекта Application, которые позволяют вашему коду размещать маркеры в основном потоке событий Visio.</p>
<p>27:22</p>
<p>	Событие позволяет вам установить контекстную  строку, которая позволяет вам определить, какие события были вызваны вашим кодом, а какие — обычными операциями Visio.</p>
<p>27:28</p>
<p>	Например, если в вашем коде есть ряд изменений ячеек, которые необходимо выполнить для шейпа, вы можете начать свои операции с создания маркера события, а затем создать еще один, когда вы закончите свою работу.</p>
<p>27:40</p>
<p>	Таким образом, любое другое прослушивание событий может игнорировать события, запускаемые операциями вашего кода, и реагировать только на события, запускаемые во время нормальной работы.</p>
<p>27:47</p>
<p>	Способ добавления MarkerEvent заключается в использовании метода QueueMarkerEvent для объекта Application. Однако MarkerEvents не обязательно использовать просто для того, чтобы начинать и заканчивать ваши операции.</p>
<p>28:10</p>
<p>	В 2002 году была представлен Add-on QueueMarkerEvent, который расширил возможности использования маркерных событий. Если вы помните, сохраняемые события могут вызывать только Add-on, а не VSTO Add-in. Таким образом, Add-on QueueMarkerEvent позволяет вам запускать сохраняемое событие, которое ваш Add-in может прослушивать и реагировать на него.</p>
<p>28:22</p>
<p>	Это распространяется на ShapeSheet. Опять же, когда вы не можете вызвать Add-in напрямую, но вы можете вызвать надстройку QueueMarkerEvent с помощью функции шейп-листа RunAddonWithArgs. А с 2002 года это было включено в собственную автономную функцию ShapeSheet, которая называется, как вы уже догадались, QueueMarkerEvent.</p>
<p>28:41</p>
<p>	Таким образом, ключевым выводом для всех аспектов QueueMarkerEvent - метода Application, Add-on и функции ShapeSheet является то, что оно позволяет запускать Add-in практически напрямую. И, что наиболее важно, прямо из ShapeSheet.</p>
<p>28:54</p>
<p>	Итак, это концептуальная сторона обработки событий в Visio.</p>
<p>28:59</p>
<p>	Теперь давайте взглянем на интеграцию этих типов событий в пример кофейни, чтобы увидеть код более подробно.</p>
<p>29:10</p>
<p>	Вот тот же макет кофейни, который мы рассматривали при изучении объектной модели.</p>
<p>29:16</p>
<p>	Вы все еще можете щелкнуть правой кнопкой мыши по шейпу стола и добавить стул. Но сейчас я хочу разобраться с тем, что происходит, когда стул удаляется. Поведение, которое я ищу, состоит в том, чтобы Visio автоматически переставлял оставшиеся стулья. Давайте посмотрим на код.</p>
<p>29:33</p>
<p>	Возможно, вы помните, что стулья размещаются только относительно целевого стола, но не имеют никакой связи с этим столом.</p>
<p>29:41</p>
<p>	Итак, что я сделал, так это объявил переменную, ссылающуюся на приложение и, что наиболее важно, используя ключевое слово WithEvents.</p>
<p>29:47</p>
<p>	WithEvents предлагает большинство, но не все события, к которым можно получить доступ с помощью AddAdvise.</p>
<p>29:54</p>
<p>	Например, раньше ShapeDeleted и ShapesDeleted были доступны как на уровне приложения, так и на уровне документа с помощью AddAdvise, но только на уровне приложения с помощью WithEvents.</p>
<p>30:07</p>
<p>	Учитывая, что я буду прослушивать события BeforeShapeDelete во всех открытых документах, мне нужно убедиться, что документ, в котором произошло событие, является правильным. И поэтому я уже добавил признак в пользовательской ячейке в шейп-листе шаблона документа, который я затем могу проверить в обработчике.</p>
<p>30:20</p>
<p>	Поэтому имейте в виду, что весь этот код находится в документе трафарета, а не в шаблоне или результирующем документе чертежа. Но в целом основной поток происходит так.</p>
<p>30:37</p>
<p>	Я слушаю событие DocumentOpened самого трафарета. И когда он запущен, я создаю новую коллекцию для хранения шейпов столов, которые будут переупорядочены, а также устанавливаю переменную Application.</p>
<p>30:49</p>
<p>	Когда форма удаляется, срабатывает событие BeforeShapeDelete, и как только мы убедимся, что говорим с нужным документом, мы можем начать работу по настройке правильной стола.</p>
<p>31:02</p>
<p>	Я хочу реагировать только на шейпы, полученные от моего мастера Chair, и если эта проверка возвращает true, мы можем перейти к выполнению того же пространственного поиска, который мы делали при добавлении стула.</p>
<p>31:08</p>
<p>	Предположим, стол найден, добавлен в коллекцию, и теперь нам просто нужно дождаться, пока Visio обработает свою собственную очередь событий, и шейпы будут фактически удалены.</p>
<p>31:21</p>
<p>	На самом деле Visio предоставляет вам специальное событие, чтобы уведомить вас, когда оно будет готово, и что никаких ожидающих событий нет.</p>
<p>31:28</p>
<p>	То есть мы можем дождаться, пока Visio будет готов, и когда это произойдет, вызвать окончательную перестановку.</p>
<p>31:36</p>
<p>	Здесь мы снова восстанавливаем Selection, меняем расположение, используя тот же радиальный макет, и, наконец, удаляем стол из коллекции TablesToArrange.</p>
<p>31:50</p>
<p>	AddAdvise и приемники событий (Event Sinks)</p>
<p>	Как видите, использование WithEvents — довольно простой метод обработки событий, однако за простоту реализации приходится платить.</p>
<p>31:55</p>
<p>	Вернемся к этой концептуальной схеме событий.</p>
<p>32:01</p>
<p>	Как вы видели, Visio поддерживает коллекцию событий для каждого исходного объекта. Эта коллекция или EventList изначально пуста, и если вы используете метод AddAdvise, вы получаете контроль над каждым элементом для каждого события, которое вы хотите создать.</p>
<p>32:16</p>
<p>	Однако, используя WithEvents, даже если вы можете обрабатывать только одно событие, ваш объект, на который ссылаются, получает события для всего спектра, доступного для этого объекта.</p>
<p>32:27</p>
<p> 	И если вы проверите EventList вашего эталонного исходного объекта, вы обнаружите, что он полностью заполнен, хотите вы этого или нет.</p>
<p>32:32</p>
<p>	Использование обработки событий на основе делегатов, которую мы рассмотрим через секунду, также страдает от той же проблемы.</p>
<p>32:38</p>
<p>	Тогда лучшим решением будет использовать AddAdvise. Используя этот метод, вы можете определить свой собственный класс, которому Visio отправит уведомление о том, что произошло событие.</p>
<p>32:49</p>
<p>	Вы начинаете с получения ссылки на ваш целевой исходный объект и вызова AddAdvise в его EventList.</p>
<p>32:56</p>
<p>	В рамках этого вызова вы передаете ссылку на экземпляр вашего класса EventSync, и это то, что Visio использует для запуска уведомления.</p>
<p>33:08</p>
<p>	Итак, теперь у нас есть все компоненты. Давайте перейдем к эквивалентному решению VSTO и рассмотрим как события на основе делегатов, так и использование AddAdvise и нашего собственного EventSync для перехвата других событий.</p>
<p>33:14</p>
<p>	Итак, мы вернулись к тому же шаблону кофейни, который видели ранее. Этот чертеж поддерживает добавление, удаление и перестановку стульев, как и раньше. Но на этот раз шаблон полностью свободен от кода, и все действия происходят в VSTO Add-in.</p>
<p>33:34</p>
<p>	Пока мы работаем в Visio, я посмотрю, как вызывается функция AddChair. Наше предыдущее решение VBA основывалось на вызове этой функции из ShapeSheet. Но теперь мы в надстройке, и вместо этого мы можем использовать функцию QueueMarkerEvent.	</p>
<p>33:48</p>
<p>	Используя эту функцию, мы можем передать событию контекстную строку, в которую я включаю как ID решения, так и команду, которую хочу выполнить.</p>
<p>33:54</p>
<p>	Если мы теперь перейдем к Visual Studio, вы увидите, что есть ряд вещей, которые нам нужно подключить к Add-in по мере его загрузки.</p>
<p>34:06</p>
<p>	Прежде всего, я создаю небольшой класс Parser, чтобы иметь возможность воспринимать контекстную строку осмысленным образом.</p>
<p>34:11</p>
<p>	Как только это будет готово, я затем подключаю некоторое начальное прослушивание событий, используя события делегата.</p>
<p>34:18</p>
<p>	Обратите внимание, что в первую строку я включил полное имя делегата, которое дает вам Visio API, чтобы вы могли видеть, что происходит.</p>
<p>34:24</p>
<p>	Он помечен как избыточный, потому что компилятор определяет тип и позволяет вам просто добавить ссылку на метод обработчика. Таким образом, DocumentCreated будет срабатывать при создании нового чертежа из шаблона.</p>
<p>34:37</p>
<p>	В то время как DocumentOpened срабатывает при открытии существующего документа чертежа.</p>
<p>34:46</p>
<p>	В любом случае я затем проверяю, основан ли документ, вызвавший событие, на этом решении.</p>
<p>34:51</p>
<p>	А если да, то добавляю в коллекцию просмотренных документов.</p>
<p>34:57</p>
<p>	Кроме того, если это первый элемент в коллекции, я начинаю прослушивание MarkerEvents в объекте Application.</p>
<p>35:02</p>
<p>	На самом деле я оборачиваю просматриваемые документы в отдельный класс с именем DocWrapper, и именно здесь я подключаю дальнейшее прослушивание событий в самом документе.</p>
<p>35:08</p>
<p>	Давайте перейдем к классу DocWrapper. Где вы можете видеть, что оставшееся прослушивание событий подключается во время построения классов.</p>
<p>35:20</p>
<p>	На этот раз я использую метод AddAdvise, а не события делегата. Обычно вы бы выбрали только один метод, но в демонстрационных целях я хотел показать оба метода.</p>
<p>35:32</p>
<p>	С помощью AddAdvise я получаю объект EventList документа, создаю новый класс EventSync, а затем вызываю метод AddAdvise для EventList, передавая код события и экземпляр EventSync.</p>
<p>35:45</p>
<p>	Метод AddAdvise возвращает объект Event, который я храню в списке для поддержания ссылки.</p>
<p>35:53</p>
<p>	Итак, на данном этапе все подключено, и мы просто ждем, пока кто-нибудь добавит или удалит кресло.</p>
<p>35:59</p>
<p>	Вы помните, что случае добавления стула функция QueueMarkerEvent ShapeSheet запускается, и поскольку я сейчас слушаю MarkerEvents, она обрабатывается в этом методе.</p>
<p>36:09</p>
<p>	Учитывая, что может быть запущено много событий MarkerEvent, а не только из этой надстройки, первое, что нужно сделать, — это проверить, предназначено ли это событие для этого решения.</p>
<p>36:15</p>
<p>	Если да, то мы можем продолжить и обработать полученную контекстную строку. Я не собираюсь рассматривать это сейчас, так как я действительно хочу сосредоточиться на стороне событий, а код, по сути, является версией C# того же кода VBA, который вы видели, когда мы рассматривали пример с событиями.</p>
<p>36:32</p>
<p>	С другой стороны, если фигура удалена, Visio уведомит наш класс EventSync о событиях, на которые мы подписались.</p>
<p>36:44</p>
<p>	Итак, давайте, наконец, посмотрим на метод Sync и VisEventProc, определенный интерфейсом.</p>
<p>36:51</p>
<p>	В этом случае мы проверяем код входящего события, и если это событие - BeforeSelectionDelete, то добавляем выделенное в очередь, а затем обрабатываем шейпы столов в этой очереди, когда Visio запускает событие NoEventsPending.</p>
<p>37:03</p>
<p>	Вы можете увидеть два метода, которые выполняют эту работу в классе FurnitureManager.</p>
<p>37:08</p>
<p>	Один для получения таблицы, связанной со стулом, который будет удален, и один для перестановки оставшихся стульев после того, как Visio фактически завершит удаление целевого стула.</p>
<p>37:20</p>
<p>	Решение завершается удалением просматриваемого документа из коллекции при закрытии документа. И если это последний в нашей коллекции, мы также можем перестать прослушивать MarkerEvents.</p>
<p>37:40</p>
<p>	И последнее, но не менее важное: этот метод завершения работы надстройки вызывает связанный с ним метод Disconnect, чтобы отменить подписку на оставшиеся события делегата, когда Add-in выгружается.</p>
<p>37:47</p>
<p>	И имейте в виду, что это может произойти до закрытия хост-приложения.</p>
<p>37:55</p>
<p>	Обработка событий Visio</p>
<p>	Итак, мы завершаем наш обзор событий в Visio. Как вы видели, есть несколько вариантов. И главное, на что следует обратить внимание, — это уровень, на котором вы прослушиваете события. Старайтесь сузить область действия, когда это возможно. И метод, которым вы подключаетесь к Visio.</p>
<p>38:14</p>
<p>	Предпочтительно AddAdvise и EventSync уведомление, а не болтовня с событиями.</p>
<p>38:22</p>
<p>	Развертывание решения Visio</p>
<p>	Итак, вы создали новый трафарет и шаблон для решения, выбрали модель кодирования и создали сборку.</p>
<p>38:29</p>
<p>	Теперь пришло время перенести все эти элементы на машину конечного пользователя. В зависимости от того, создаете ли вы Add-on или Add-in, решение можно рассматривать как состоящее из двух основных частей: кода и содержимого. Для развертывания кода вы можете заключить все в установщик Windows MSI или использовать Click Once.</p>
<p>38:53</p>
<p>	Развертывание контента</p>
<p>	Я собираюсь вернуться к этим двум вариантам через минуту, но сначала давайте посмотрим, что происходит с точки зрения контента.</p>
<p>	В Visio есть два метода поиска предоставленных вами файлов и представления их в пользовательском интерфейсе.</p>
<p>39:04</p>
<p>	Первый — это обнаружение путей, а второй — публикация. Если вы откроете диалоговое окно параметров и заглянете на вкладку "Дополнительно", вы найдете кнопку "Расположение файлов".</p>
<p>39:18</p>
<p>	Щелкнув по нему, вы откроете дополнительное диалоговое окно, в котором показано несколько путей к папкам для различных типов файлов. Это составляет основу исходного метода предоставления Visio ряда мест для поиска в файловой системе наборов элементов, шаблонов, файлов справки и надстроек.</p>
<p>39:31</p>
<p>	При каждом запуске Visio проверяет расположение этих файлов, чтобы сделать их доступными через пользовательский интерфейс. Эта система обнаружения пути остается и сегодня, однако в Visio 2003 появился новый метод, называемый публикацией.</p>
<p>39:48</p>
<p>	Этот новый метод включал публикацию всех сведений о ваших файлах содержимого в реестре.</p>
<p>39:55</p>
<p>	Затем Visio просматривает реестр и создает кэш сведений о содержимом, что избавляет его от необходимости просматривать файловую систему или реестр при каждом запуске.</p>
<p>40:08</p>
<p>	Он будет повторно сканировать реестр и обновлять кешированную версию только при изменении определенного значения или если не сможет найти файл кеша.</p>
<p>40:14</p>
<p>	Я должен отметить, что хотя ранее я упомянул о разделении между контентом и кодом, на самом деле Add-on также делятся на использующие обнаружение пути или публикацию.</p>
<p>40:28</p>
<p>	Это отличается от Add-in, которые используют только другой ключ в реестре, чтобы определить, как они загружаются.</p>
<p>40:36</p>
<p>	Публикация</p>
<p>	Помимо возможности кэшировать местоположения файлов содержимого, публикация предлагает ряд других преимуществ.</p>
<p>40:42</p>
<p>	Она позволяет Add-on быть доверенными по умолчанию. Это позволяет вам выбирать, где находятся файлы, но не заставляет вас использовать это местоположение в пользовательском интерфейсе, что не относится к обнаружению пути.</p>
<p>40:54</p>
<p>	Она обеспечивает поддержку многоязычных версий файлов, как специфичных, так и резервных, а при использовании корня MSI вы получаете преимущества таких функций установщика Windows, как отказоустойчивость, которая автоматически восстанавливает ваши файлы по мере необходимости.</p>
<p>41:06</p>
<p>	И простая установка и удаление с помощью программ и функций Windows. Если вы не знакомы с файлами MSI, они в основном представляют собой установочный пакет, который помимо содержания всех ресурсов для установки включает базу данных, в которой описаны все части и шаги, необходимые для выполнения установки.</p>
<p>41:30</p>
<p>	Одна из таблиц в базе данных называется таблицей PublishComponents, и именно сюда добавляется список всех трафаретов, шаблонов, Add-on и файлов справки.</p>
<p>41:36</p>
<p>	В Visio есть набор известных вещей, которые он использует для уникальной идентификации каждого типа контента, а также ряд дополнительных параметров, таких как идентификатор локали, путь в меню и альтернативные имена файлов, которые дают вам все необходимое для публикации вашего контента, чтобы он правильно отображался в пользовательском интерфейсе.</p>
<p>41:56</p>
<p>	Вы можете добавить все эти настройки вручную в MSI с помощью такого инструмента, как ORCA, который является частью Windows SDK, или как часть создания MSI с помощью WIX.</p>
<p>42:10</p>
<p>	Однако более простой способ — использовать средство, входящее в состав Visio SDK, которое называется Visio Solution Publishing Tool.</p>
<p>42:16</p>
<p>	Это дает вам удобный пользовательский интерфейс для редактирования всех деталей и обеспечивает интеграцию в MSI. Процесс использования инструмента выглядит следующим образом:</p>
<p>42:27</p>
<p>	Вы добавляете файлы содержимого в Setup проект, создаете проект для создания MSI и, наконец, открываете MSI в инструменте публикации.</p>
<p>42:38</p>
<p>	Например, вот проект надстройки VSTO Add-in со связанным Setup проектом. Я сослался на трафарет и шаблон, которые я хочу установить в рамках проекта установки, в папку, которую я решил назвать VisioContent.</p>
<p>42:51</p>
<p>	Если я соберу проект, будет сгенерирован MSI, после чего я смогу открыть инструмент публикации и указать ему на только что созданный пакет. Здесь вы можете видеть, что я добавил собственный путь в меню, и если я открою элемент шаблона, вы также увидите все свойства, доступные для установки.</p>
<p>43:09</p>
<p>	Со всем этим я могу установить MSI и увидеть свой новый шаблон, созданный как часть стандартного пользовательского интерфейса в Visio, в предопределенной папке.</p>
<p>43:16</p>
<p>	Помимо пользовательского интерфейса Solution Publishing Tool также имеет интерфейс командной строки, позволяющий интегрировать инструмент в процесс сборки.</p>
<p>43:28</p>
<p>	И если вы заинтересованы в этом, вам следует заглянуть в файл справки, который поставляется с инструментом.</p>
<p>43:33</p>
<p>	Варианты развертывания</p>
<p>	Итак, это два метода обслуживания содержимого в пользовательском интерфейсе Visio. А теперь я собираюсь вернуться к тому, как вы выбираете модель развертывания. Я не собираюсь вдаваться в разговор об относительных преимуществах Click Once по сравнению с установщиком Windows.</p>
<p>43:46</p>
<p>	Я действительно хочу посмотреть на это с точки зрения Visio. И я собираюсь упростить это до ваших требований к файлам трафаретов и шаблонов, о которых мы только что говорили, и того, нужно ли вам, чтобы ваше решение было развернуто для каждого пользователя или для всех пользователей.</p>
<p>43:58</p>
<p>	Вы можете видеть, что корень MSI допускает все параметры, в то время как Click Once поддерживает только более ограниченный набор. Ограничения Click Once связаны с тем, что нельзя записывать в локальный куст реестра. И это требование для того, чтобы ваша надстройка работала для всех пользователей, а также для публикации контента Visio.</p>
<p>44:23</p>
<p>	Если у вас нет контента для развертывания, Click Once — очень удобный вариант.</p>
<p>44:28</p>
<p>	Это также вариант, если вы довольны методом обнаружения путей и готовы проделать немного больше работы, отредактировав манифест развертывания, чтобы добавить действие после развертывания.</p>
<p>44:33</p>
<p>	Это потребует повторного подписания манифеста с помощью mage, и вы можете найти пример сценария, который автоматизирует все эти шаги, в Visio SDK.</p>
<p>44:45</p>
<p>	Просто имейте в виду, что стандартный надстройка VSTO Add-in, развернутый с помощью Click Once, не поддерживает дополнительные файлы так же, как это делает автономный EXE-файл с развертыванием Click Once.</p>
<p>44:58</p>
<p>	В целом вам действительно следует рассматривать Click Once как механизм развертывания по умолчанию, если у вас нет особых потребностей, выходящих за рамки этого, таких как развертывание для всех пользователей или оговорки о публикации, которые я выделил.</p>
<p>45:15</p>
<p>	Итак, flyby курс по Visio завершен.	</p>
<p>	Как я сказал в начале, он был сосредоточен на концепциях, а не на деталях. Итак, я надеюсь, что теперь у вас есть полное представление о том, как работает Visio, и у вас есть структура, где хранить подробную информацию о различных документах и контенте.</p>
<p>	Спасибо за просмотр.</p>
</body></html>